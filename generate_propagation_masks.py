#!/usr/bin/env python3
"""
Generates precomputed propagation direction masks for VoxelisX dirty propagation system.
Outputs C# array initialization code that can be pasted directly into Sector.cs
"""

# 26 neighbor directions (Moore neighborhood)
# Matches NeighborhoodSettings.Directions in C#
DIRECTIONS = [
    # Face neighbors (0-5)
    (1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1),
    # Edge neighbors (6-17)
    (1, 1, 0), (1, -1, 0), (-1, 1, 0), (-1, -1, 0),
    (1, 0, 1), (1, 0, -1), (-1, 0, 1), (-1, 0, -1),
    (0, 1, 1), (0, 1, -1), (0, -1, 1), (0, -1, -1),
    # Corner neighbors (18-25)
    (1, 1, 1), (1, 1, -1), (1, -1, 1), (1, -1, -1),
    (-1, 1, 1), (-1, 1, -1), (-1, -1, 1), (-1, -1, -1),
]


def compute_boundary_direction_mask(x, y, z, side_length):
    """
    Computes which neighbor directions need propagation based on position within a volume.
    Matches ComputeBoundaryDirectionMask in Sector.cs

    Args:
        x, y, z: Coordinates within volume
        side_length: Side length of the volume (8 for brick, 16 for sector)

    Returns:
        uint bitmask where bit i indicates if direction i needs propagation
    """
    max_coord = side_length - 1

    # Determine which boundaries this position is at
    at_min_x = (x == 0)
    at_max_x = (x == max_coord)
    at_min_y = (y == 0)
    at_max_y = (y == max_coord)
    at_min_z = (z == 0)
    at_max_z = (z == max_coord)

    mask = 0

    # For each of the 26 neighbor directions, check if we're at the corresponding boundary
    for dir_idx, direction in enumerate(DIRECTIONS):
        dx, dy, dz = direction
        at_boundary = True

        # Check if we're at the required boundary for this direction
        if dx < 0 and not at_min_x:
            at_boundary = False
        if dx > 0 and not at_max_x:
            at_boundary = False
        if dy < 0 and not at_min_y:
            at_boundary = False
        if dy > 0 and not at_max_y:
            at_boundary = False
        if dz < 0 and not at_min_z:
            at_boundary = False
        if dz > 0 and not at_max_z:
            at_boundary = False

        if at_boundary:
            mask |= (1 << dir_idx)

    return mask


def to_block_idx(x, y, z, side_length):
    """Converts 3D coordinates to flat index"""
    return x + y * side_length + z * side_length * side_length


def generate_voxel_masks():
    """Generate voxel propagation masks (512 entries for 8x8x8)"""
    side_length = 8
    total = side_length ** 3
    masks = []

    for z in range(side_length):
        for y in range(side_length):
            for x in range(side_length):
                mask = compute_boundary_direction_mask(x, y, z, side_length)
                masks.append(mask)

    assert len(masks) == total
    return masks


def generate_brick_masks():
    """Generate brick sector neighbor masks (4096 entries for 16x16x16)"""
    side_length = 16
    total = side_length ** 3
    masks = []

    for z in range(side_length):
        for y in range(side_length):
            for x in range(side_length):
                mask = compute_boundary_direction_mask(x, y, z, side_length)
                masks.append(mask)

    assert len(masks) == total
    return masks


def format_csharp_array(masks, name, per_line=8):
    """Format masks as C# array initialization code"""
    lines = []
    lines.append(f"        private static readonly uint[] {name} = new uint[{len(masks)}]")
    lines.append("        {")

    # Group masks into lines
    for i in range(0, len(masks), per_line):
        chunk = masks[i:i+per_line]
        values = ", ".join(f"0x{m:08X}" for m in chunk)
        if i + per_line >= len(masks):
            lines.append(f"            {values}")
        else:
            lines.append(f"            {values},")

    lines.append("        };")
    return "\n".join(lines)


def main():
    print("// ========================================")
    print("// Precomputed Propagation Direction Masks")
    print("// Generated by generate_propagation_masks.py")
    print("// ========================================")
    print()

    # Generate voxel masks
    print("/// <summary>")
    print("/// Precomputed lookup table for voxel position to propagation direction mask.")
    print("/// Index: voxel flat index within brick (0-511), Value: bitmask of 26 neighbor directions.")
    print("/// </summary>")
    voxel_masks = generate_voxel_masks()
    print(format_csharp_array(voxel_masks, "s_voxelPropagationMasks"))
    print()

    # Generate brick masks
    print("/// <summary>")
    print("/// Precomputed lookup table for brick position to sector neighbor directions.")
    print("/// Index: brick flat index (0-4095), Value: bitmask of 26 sector neighbor directions this brick touches.")
    print("/// </summary>")
    brick_masks = generate_brick_masks()
    print(format_csharp_array(brick_masks, "s_brickSectorNeighborMasks"))
    print()

    # Print statistics
    print(f"// Voxel masks: {len(voxel_masks)} entries, {len(voxel_masks) * 4} bytes")
    print(f"// Brick masks: {len(brick_masks)} entries, {len(brick_masks) * 4} bytes")
    print(f"// Total: {(len(voxel_masks) + len(brick_masks)) * 4} bytes")


if __name__ == "__main__":
    main()
